package com.example.csce490m3research;

import androidx.annotation.NonNull;

import com.google.android.gms.tasks.OnCompleteListener;
import com.google.android.gms.tasks.Task;
import com.google.firebase.auth.FirebaseAuth;
import com.google.firebase.firestore.CollectionReference;
import com.google.firebase.firestore.DocumentReference;
import com.google.firebase.firestore.FirebaseFirestore;
import com.google.firebase.firestore.FirebaseFirestoreSettings;
import com.google.firebase.firestore.Query;
import com.google.firebase.firestore.QueryDocumentSnapshot;
import com.google.firebase.firestore.QuerySnapshot;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/** Static class to handle database operations.
 *  Backed by Firebase Firestore, which essentially stores data in an alternating collection/
 *  document tree structure. i.e., A collection can have multiple documents, and a document is
 *  a map with fields keyed by strings. A document can also contain one or more collections, and
 *  so on.
 *
 *  iTipper uses three collections at the database root:
 *
 *  "shifts", a collection of shifts with auto-generated keys. Each shift document has a
 *  "start" and "end" field, which are stored as Firebase Timestamp objects, and a "uid",
 *  which is a string generated by Firebase Auth, and is unique to each user.
 *
 *  "tips", a collection of tips with auto-generated keys. Each tip document has a "time" field,
 *  which is a Firebase Timestamp, "uid", and "value", which is a number for the dollar value of
 *  the tip.
 *
 *  "users", keyed by uid. The only field so far (4/25/2020) is "last_login", a Timestamp.
 *
 *  Authors: Tyler Chambers
 */
class Database {

    /**
     * Write a tip out to the database. Automatically fill in the uid field with the currently
     * signed-in user and the time field with the timestamp at which this method is called.
     * @param tipValue The value of the tip to add, as a string that can be parsed as a double.
     * @throws InvalidTipException: if tipValue <= 0.
     */
    static void writeTip(String tipValue) throws InvalidTipException {
        CollectionReference tips = tipsReference();

        // Tip to be written
        Tip tip = new Tip(tipValue);

        Map<String, Object> data = new HashMap<>();
        data.put("uid", getUID());
        data.put("value", tip.getValue());
        data.put("time", tip.getTime());

        tips.add(data);
    }

    /**
     * Write a tip out to database, providing a Tip object.
     * @param tip A Tip object, with uid, value, and time instantiated.
     */
    static void writeTip(Tip tip) {
        CollectionReference tips = tipsReference();

        Map<String, Object> data = new HashMap<>();
        data.put("uid", getUID());
        data.put("value", tip.getValue());
        data.put("time", tip.getTime());

        tips.add(data);
    }

    /**
     * Read tips that the user has input to the database.
     * @param callback A ListCallback interface, which must be implemented when this is called.
     */
    static void loadTips(final ListCallback callback) {
        Query tipsRef = FirebaseFirestore.getInstance()
                .collection("tips")
                .whereEqualTo("uid", getUID())
                .orderBy("time", Query.Direction.ASCENDING);

        tipsRef.get().addOnCompleteListener(new OnCompleteListener<QuerySnapshot>() {
            @Override
            public void onComplete(@NonNull Task<QuerySnapshot> task) {
                if (task.isSuccessful()) {
                    List<Tip> tipsList = new ArrayList<>();

                    QuerySnapshot results = task.getResult();

                    if (results != null) {
                        for (QueryDocumentSnapshot document : results) {
                            Tip tip = new Tip(document.getData());
                            tipsList.add(tip);
                        }
                    }
                    callback.onCallback(tipsList);
                }
            }
        });
    }
    public static void getShifts(final ShiftCallBack callback) {
        Query shiftsRef = shiftsReference()
                .whereEqualTo("uid", getUID())
                .orderBy("start", Query.Direction.DESCENDING);
        final Query tipsRef = FirebaseFirestore.getInstance()
                .collection("tips")
                .whereEqualTo("uid", getUID())
                .orderBy("time", Query.Direction.ASCENDING);

        shiftsRef.get().addOnCompleteListener(new OnCompleteListener<QuerySnapshot>() {
            @Override
            public void onComplete(@NonNull Task<QuerySnapshot> task) {
                if (task.isSuccessful()) {
                    final List<Shift> shiftList = new ArrayList<>(1);
                    for (QueryDocumentSnapshot document : task.getResult()) {
                        Shift shift = new Shift(document.getData());
                        shiftList.add(shift);

                    }
                    tipsRef.get().addOnCompleteListener(new OnCompleteListener<QuerySnapshot>() {
                        @Override
                        public void onComplete(@NonNull Task<QuerySnapshot> task) {
                            if (task.isSuccessful()) {
                                List<Tip> tipsList = new ArrayList<>();
                                for (QueryDocumentSnapshot document : task.getResult()) {
                                    Tip tip = new Tip(document.getData());
                                    tipsList.add(tip);
                                }
                                callback.onCallback(tipsList,shiftList);
                            }
                        }
                    });
                }
            }
        });

    }

    /**
     * Find the most recent shift started by the user in the database.
     * The shift could either be complete, in which case it will have both a start and end field,
     * or it might still be ongoing, and only have a start field.
     * @param callback A ListCallback interface, which must be implemented when this is called.
     */
    static void getMostRecentShift(final ListCallback callback) {
        Query shiftsRef = shiftsReference()
                .whereEqualTo("uid", getUID())
                .orderBy("start", Query.Direction.DESCENDING)
                .limit(1);

        shiftsRef.get().addOnCompleteListener(new OnCompleteListener<QuerySnapshot>() {
            @Override
            public void onComplete(@NonNull Task<QuerySnapshot> task) {
                if (task.isSuccessful()) {
                    List<Shift> shiftList = new ArrayList<>(1);

                    QuerySnapshot results = task.getResult();

                    if (results != null) {
                        for (QueryDocumentSnapshot document : task.getResult()) {
                            Shift shift = new Shift(document.getData());
                            shiftList.add(shift);
                        }
                    }
                    callback.onCallback(shiftList);
                }
            }
        });
    }
    /**
     * Get a reference to the user's document in the users collection.
     * @return Database reference for the signed in user's document.
     */
    static DocumentReference userReference() {
        String UID = getUID();

        FirebaseFirestore mFirestore = FirebaseFirestore.getInstance();
        FirebaseFirestoreSettings settings = new FirebaseFirestoreSettings.Builder()
                .build();
        mFirestore.setFirestoreSettings(settings);

        return mFirestore.collection("users").document(UID);
    }

    /**
     * Get a reference to the tips collection in the Firestore database.
     * @return A CollectionReference to the "tips" collection at the database root.
     */
    private static CollectionReference tipsReference() {
        FirebaseFirestore mFirestore = FirebaseFirestore.getInstance();
        FirebaseFirestoreSettings settings = new FirebaseFirestoreSettings.Builder()
                .build();
        mFirestore.setFirestoreSettings(settings);

        return mFirestore.collection("tips");
    }

    /**
     * Get a reference to the shifts collection in the Firestore database.
     * @return A CollectionReference to the "shifts" collection at the database root.
     */
    static CollectionReference shiftsReference() {
        FirebaseFirestore mFirestore = FirebaseFirestore.getInstance();
        FirebaseFirestoreSettings settings = new FirebaseFirestoreSettings.Builder()
                .build();
        mFirestore.setFirestoreSettings(settings);

        return mFirestore.collection("shifts");
    }

    /**
     * Get the current user's UID, if they are logged in.
     * @return FirebaseAuth User ID for the currently signed in user.
     */
    static String getUID() {
        String uid = FirebaseAuth.getInstance().getUid();

        if (uid != null) {
            return uid;
        } else {
            return "default_user";
        }
    }
}
